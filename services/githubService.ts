import { Files } from '../types';

const GITHUB_API_BASE = 'https://api.github.com';

async function githubApiRequest(endpoint: string, token: string, options: RequestInit = {}) {
  const headers = {
    'Authorization': `token ${token}`,
    'Accept': 'application/vnd.github.v3+json',
    'Content-Type': 'application/json',
    ...options.headers,
  };

  const response = await fetch(`${GITHUB_API_BASE}${endpoint}`, { ...options, headers });

  if (!response.ok) {
    const errorData = await response.json();
    let errorMessage = errorData.message || `GitHub API error: ${response.status}`;
    // GitHub API often includes more details in an 'errors' array.
    if (errorData.errors && Array.isArray(errorData.errors) && errorData.errors.length > 0) {
        const detailedErrors = errorData.errors.map((e: any) => e.message || JSON.stringify(e)).join(', ');
        errorMessage += `: ${detailedErrors}`;
    }
    throw new Error(errorMessage);
  }

  // Handle cases where there is no response body (e.g., 204 No Content)
  const contentType = response.headers.get("content-type");
  if (contentType && contentType.indexOf("application/json") !== -1) {
    return response.json();
  }
  return null;
}

export async function verifyToken(token: string) {
  try {
    const user = await githubApiRequest('/user', token);
    return user;
  } catch (error) {
    console.error('GitHub token verification failed:', error);
    throw new Error('Invalid or expired Personal Access Token.');
  }
}

export async function createRepo(token: string, name: string, isPrivate: boolean) {
  try {
    const repo = await githubApiRequest('/user/repos', token, {
      method: 'POST',
      body: JSON.stringify({
        name,
        "private": isPrivate,
        description: 'Project generated by MominAI',
        auto_init: true, // Creates an initial commit with a README
      }),
    });
    return repo;
  } catch (error) {
     console.error('GitHub repo creation failed:', error);
     if (error instanceof Error) {
        if (error.message.includes('name already exists')) {
            throw new Error('A repository with this name already exists on your account.');
        }
        // Re-throw the detailed error message from the API for other failures.
        throw new Error(`Repository creation failed. Reason: ${error.message}`);
     }
     // Fallback for non-Error objects
     throw new Error('Failed to create repository due to an unknown error.');
  }
}

export async function pushFiles(token: string, owner: string, repo: string, files: Files, message: string) {
  // 1. Get the latest commit SHA of the main branch
  const branch = await githubApiRequest(`/repos/${owner}/${repo}/branches/main`, token);
  const latestCommitSha = branch.commit.sha;
  const baseTreeSha = branch.commit.commit.tree.sha;

  // 2. Create a blob for each file
  const blobCreationPromises = Object.entries(files).map(([path, content]) =>
    githubApiRequest(`/repos/${owner}/${repo}/git/blobs`, token, {
      method: 'POST',
      body: JSON.stringify({ content, encoding: 'utf-8' }),
    }).then(blob => ({ path, sha: blob.sha, mode: '100644', type: 'blob' }))
  );
  const treeItems = await Promise.all(blobCreationPromises);

  // 3. Create a new tree with the new file blobs
  const newTree = await githubApiRequest(`/repos/${owner}/${repo}/git/trees`, token, {
    method: 'POST',
    body: JSON.stringify({
      base_tree: baseTreeSha,
      tree: treeItems,
    }),
  });
  
  // 4. Create a new commit pointing to the new tree
  const newCommit = await githubApiRequest(`/repos/${owner}/${repo}/git/commits`, token, {
    method: 'POST',
    body: JSON.stringify({
      message,
      tree: newTree.sha,
      parents: [latestCommitSha],
    }),
  });

  // 5. Update the branch reference to point to the new commit
  await githubApiRequest(`/repos/${owner}/${repo}/git/refs/heads/main`, token, {
    method: 'PATCH',
    body: JSON.stringify({
      sha: newCommit.sha,
    }),
  });
}
